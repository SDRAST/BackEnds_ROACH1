import logging
import Pyro5

import MonitorControl as MC
import support

logger = logging.getLogger(__name__)

max_spectra_per_scan = 120 # 1 h at 5 s per spectrum
  
############################# module methods ################################

def roach_name_adaptor(func):
    """
    If we send the number of the roach instead of the roach name, it will still
    work. This will make it easier for this code to adapt to existing client
    side use cases.
    
    The convention is that the DTO ROACHs, at least, are known by names
    ("roach1", "roach2") or by index numbers (0, 1).
    
    Note that the ROACH name or number must be the first argument.
    """
    def wrapper(self, n, *args):
        template = self.template
        name = n
        if isinstance(n, int):
            if template == 'sao':
                name = "{}64k-{}".format(template, n)
            elif template == 'roach':
                name = "{}{}".format(template, n+1)
        return func(self, name, *args)
    return wrapper

################################ classes #################################
@Pyro5.api.expose
class SAObackend(support.PropertiedClass):
  """
  A simulated multi-ROACH 32k-channel x 4-IF spectrometer

  An SAO back end normally comprises four ROACH boards using TAMS 32K channel
  firmware.  We will generalize it, though, to use any number of ROACH boards.

  Attributes::
  accum_report - list start-times of accumulations, cleared for each scan
  logger       - logging.Logger instance
  name         - name for the backend
  reader       - dict of DeviceReadThread objects keyed to roach names
  roach        - dict of SAOfwif objects keyed to their names

  The backend manages the scans for the child ROACH objects.  Their scan
  numbers are updated when the required number of records have been recorded.

  Typically, the SAO client is an attribute of the main client so that the
  server's methods are called with::
    client.spectrometer.hardware.method()
  """
  def __init__(self, name, roaches=None,
                     roachlist=['roach1', 'roach2', 'roach3', 'roach4'], 
                     template='sao',
                     synth=None, write_to_disk=False, TAMS_logging=False):
    """
    Initialise a multi-IF high-res spectrometer.

    @param name : name for the backend
    @type  name : str

    @param roaches : optional list of TAMS-programmed ROACHes
    @type  roaches : list of SAOfwif instances

    @param roachlist : list of unitialized ROACHs by hostname; default: all
    @type  roachlist : list of str

    @param template : template for finding ROACHes in /etc/hosts
    @type  template : str

    @param synth : a synthesizer object
    """
    mylogger = logging.getLogger(module_logger.name + ".SAObackend")
    PropertiedClass.__init__(self)
    self.name = name # this may be a problem with Pyro
    self.logger = mylogger
    self.roach = {}
    for name in roachlist:
      # make unitialized ROACH
      roaches[name] = None
    roachkeys = roaches.keys()
    roachkeys.sort()
    for name in roachkeys:
      self.rf_enabled[name] = {}
      init = dict(parent=self,
                  roach=name,
                  template=self._template,
                  firmware_server=firmware_server,
                  firmware_key='sao_spec',
                  roach_log_level=logging.INFO,
                  clock_synth=synth,
                  writer_queue=None,
                  TAMS_logging=TAMS_logging)
      self.roach[name] = SAOfwif(**init)
      self.roach[name].scan = 0
      self.enabled[name] = {
        0: {0: None}
      }
      self.rf_state(name)
    self.logger.debug("__init__: completed for %s", self.name)

  @property
  def roachnames(self):
      return self.roach.keys()

  @property
  def template(self):
    return self._template

  def set_integration(self, int_time):
    """
    Sets all ROACHes to the same integration time.
    """
    for name in self.roach.keys():
      self.roach[name].acc_time_set(acc_time=int_time)

  @Pyro5.api.oneway
  def quit(self):
    """
    """
    for roach in self.roach.keys():
      self.roach[roach].quit()

  def help(self):
    """
    """
    return get_help(self.__class__)
  
  @Pyro5.api.oneway
  def start(self, n_accums=max_spectra_per_scan, integration_time=10.0):
    """
    start a scan consisting of 'n_accums' accumulations

    Adapted from SAObackend.start and SAObackend.action
    """
    self.logger.debug("start: called for %d accumulations", n_accums)
    for name in self.roach.keys():
      self.logger.debug("start: starting %s", name)
      self.roach[name].max_count = n_accums
      self.roach[name].acc_count = -1 # so first one is zero
      self.accum_report[name] = []
    self.set_integrations(integration_time)

  def reset_scans(self):
    for name in self.roach:
      self.roach[name].scan = 0

  @roach_name_adaptor
  def firmware(self, roachname):
    """
    returns firmware loaded in specified ROACH
    Example::
      In [6]: k.firmware('roach2')
      Out[6]: 'kurt_spec'
    """
    return self.roach[roachname].firmware

  @roach_name_adaptor
  def bandwidth(self, roachname):
    """
    returns the spectrometer bandwidth

    Example::
      In [3]: k.bandwidth('roach1')
      Out[3]: 650
    """
    return self.roach[roachname].bandwidth

  @roach_name_adaptor
  def freqs(self, roachname):
    """
    returns the channel frequencies

    Example::
      In [5]: k.freqs('roach1')
      Out[5]: array([  0.00000000e+00,   6.34765625e-01,   1.26953125e+00, ...,
                       6.48095703e+02,   6.48730469e+02,   6.49365234e+02])
    """
    return self.roach[roachname].freqs

  @roach_name_adaptor
  def rf_gain_get(self, roachname, ADC=0, RF=0):
    """
    returns the gain of the specified RF channel

    Example::
      In [17]: k.rf_gain_get('roach1', 1)
      Out[17]: 20.0
    """
    # this updates the gain info for the designated roach
    self.roach[roachname].RFchannel[RF].rf_gain_get()
    # this returns the gain value
    return self.roach[roachname].RFchannel[RF].rf_gain

  @roach_name_adaptor
  def rf_state(self, roachname, ADC=0, RF=0):
    """
    returns whether the RF section is enabled or not

    Example::
      In [17]: k.rf_state('roach1')
      Out[17]: True
    """
    # this updates the gain info for the designated roach
    self.roach[roachname].RFchannel[RF].rf_gain_get()
    # this returns the enabled state
    state = self.roach[roachname].RFchannel[RF].rf_enabled
    self.enabled[roachname][0][0] = state
    return state

  @roach_name_adaptor
  def rf_gain_set(self, roachname, ADC=0, RF=0, gain=10):
    """
    returns the gain of the specified RF channel

    Example::
      In [17]: k.rf_gain_set('roach1', RF=1, gain=20)
      Out[17]: 20.0
    """
    # this updates the gain info for the designated roach
    self.roach[roachname].RFchannel[RF].rf_gain_set(gain=gain)
    # this returns the gain value
    return self.roach[roachname].RFchannel[RF].rf_gain

  @roach_name_adaptor
  def get_ADC_samples(self, roachname, RF=0):
    """
    returns ADC samples for specific ROACH and ADC input
    """
    self.logger.debug("get_ADC_samples: called for %s ADC %d", roachname, RF)
    self.logger.debug("get_ADC_samples: device is %s",
                      self.roach[roachname].RFchannel[RF])
    return self.roach[roachname].RFchannel[RF].ADC_samples()

  @roach_name_adaptor
  def get_ADC_input(self, roachname, RF=0):
    """
    returns the power levelinto the ADC

    Example::
      In [21]: k.get_ADC_input('roach1',0)
      Out[21]: {'Vrms ADC': 0.062617406666096623,
                'W ADC': 7.8418792351746437e-05,
                'dBm ADC': -11.05579850112974,
                'sample mean': -0.987548828125,
                'sample std': 15.9331823577854}
    """
    self.logger.debug("get_ADC_input: called for %s ADC %d", roachname, RF)
    self.logger.debug("get_ADC_input: device is %s",
                      self.roach[roachname].RFchannel[RF])
    return self.roach[roachname].RFchannel[RF].get_ADC_input()

  # methods for firmware

  @roach_name_adaptor
  def read_register(self, roachname, register):
    """
    returns register contents
    """
    return self.roach[roachname].read_register(register)

  # miscellaneous methods

  @roach_name_adaptor
  def check_fans(self, roachname):
    """
    check the speed of the chassis fans
    """
    response = self.roach[roachname].check_fans()
    self.logger.info("check_fans:  %s", response)
    return response

  @roach_name_adaptor
  def check_temperatures(self, roachname):
    """
    returns physical temperatures on the ROACH board
    """
    response = self.roach[roachname].get_temperatures()
    self.logger.info("check_temperatures:  %s", response)
    return response

  @roach_name_adaptor
  def clock_synth_status(self, roachname):
    """
    Returns the status of the sampling clock

    Example::
      In [27]: k.clock_synth_status('roach2')
      Out[27]: {'VCO range': (2200, 4400),
                'frequency': 1300.0,
                'label': 'Synthesizer B   ',
                'options': (0, 1, 10, 0),
                'phase lock': False,
                'rf_level': 5}
    """
    return self.roach[roachname].clock_synth.update_synth_status()

  @roach_name_adaptor
  def initialize(self, roachname):
    """Initialize the ROACH to default values."""
    self.logger.info("Initializing ROACH {}".format(roachname))
    self.roach[roachname].initialize_roach()

  @roach_name_adaptor
  def calibrate(self, roachname):
    """Calibrate the ROACH ADC."""
    self.logger.info("Calibrating ROACH {}".format(roachname))
    self.roach[roachname].calibrate()

  @roach_name_adaptor
  def fft_shift_set(self, roachname, val):
    """Set the fft shift for a specific FPGA."""
    self.logger.info(
              "Setting the fft shift for ROACH {} to {}".format(roachname, val))
    self.roach[roachname].fft_shift_set(val)

  @roach_name_adaptor
  def sync_start(self, roachname):
    """Call sync_start for specified ROACH"""
    self.logger.info(
      "Synchronizing vector accumulators for ROACH {}".format(roachname))
    self.roach[roachname].sync_start()

  @roach_name_adaptor
  def get_clk(self, roachname):
    self.logger.info("get_clk: ROACH {}".format(roachname))
    clk = self.roach[roachname].get_clk()
    return clk

  @roach_name_adaptor
  def get_adc_temp(self, roachname):
    self.logger.info("get_adc_temp: ROACH {}".format(roachname))
    self.logger.warning("get_adc_temp: the SAObackend.get_temperatures method is prefered")
    adc_temp = self.roach[roachname].get_adc_temp()
    return adc_temp

  @roach_name_adaptor
  def get_ambient_temp(self, roachname):
    self.logger.info("get_ambient_temp: ROACH {}".format(roachname))
    self.logger.warning("get_adc_temp: the SAObackend.get_temperatures method is prefered")
    ambient_temp = self.roach[roachname].get_ambient_temp()
    return ambient_temp

#--  ------------------------------- SAOfwif------------------------------------

@Pyro5.api.expose
class SAOfwif(MC.DeviceReadThread):
  """
  Class for one ROACH with SAO 32K spectrometer firmware

  Attributes::
    acc_count - current accumulation number
    gains     - RF gain (only 1 ADC and 1 RF input)
    data_file_obj  - where raw data are stored
    logger    - logging.Logger instance
    max_count - number of accumulation in a scan
    rf_gain   - gain of RF input
    scan      - number of the current group of accumulations
  Attributes inherited from SAOhwif::
    fft_shift - contents of register fft_shift
    fpga      - ROACH hardware
  """
  command_help = """
    ADC_samples(trig_level=-1, timeout=1)
       Returns ADC samples.
    acc_time_set(acc_time=1)
       Set the accumulation length in seconds
    ctrl_get()
       Reads and decodes the values from the control register.
    ctrl_set(**kwargs)
       Set control register bits.

       This is designed to do the minimum number of writes to the 'control'
       register, allowing bits simultaneously to be set, unset, toggled and
       pulsed.
    fft_shift_set(fft_shift_schedule=0)
       Sets the FFT shift schedule (divide-by-two) on each FFT stage.
    get_ADC_input()
       Get the ADC input level properties and a set of samples
    get_RF_input()
       Get the mean RF section input level. This is the ADC level minus the
       gain of the RF section
    get_accum_count()
    get_gains()
       Get the gains of the RF channels. This only works for ADC type 'katadc'.
       The gain is set by a 20 dB amplifier followed by a -31.5 to 0 dB
       attenuator controllable in 0.5 dB steps.  So the actual gain goes from
       -11.5 dB to +20 dB in 0.5 dB steps.
    get_next_accum()
    get_spectrum()
    initialize_roach(RF_gain=10, acc_time=1)
       Initialises the system to defaults.
    quit()
    read_fpga_uscram(store=0)
    rf_gain_set(gain=20)
       Enables the RF switch and configures the RF attenuators.
       For KATADC boards. KATADC's valid range is -11.5 to 20dB. The RF switch
       is in MSb.
    write_to_data_file(data)
       Save a record
    sync_start()
       Initiate the sync pulses

    Methods inherited from MonitorControl.BackEnds.ROACH1.ROACHhwif.ROACHhwif:

    get_params(key)
       Look up the parameters for the design identified by the key
    get_register_values()
       Report on the contents of regular registers.
    listdev()
       List the devices defined in the firmware.
    report()
       Get a summary of information for this ROACH

    Methods inherited from MonitorControl.BackEnds.ROACH1.ROACHhwif.ROACHppc:

    check_borph_status()
       See if the borphserver is running bormally and fix it if not.
    get_bitfile()
       What boffile is running?
    get_boffiles(filter_tutorials=True)
       What boffiles does it have?
    get_firmware_ID()
       Get the firmware IDs of the currently loaded boffiles
    get_firmware_keys()
       Sets (and returns) the names of the firmwares available on this host
    is_alive()
       Is it alive?
    roach_command(self, command)
       Send a command to the ROACH PPC."""

  max_data_file_size = 1e9
  file_attr_keys = ['sys_board_id', 'sys_rev', 'sys_rev_rcs']
  scan_attr_keys = ['control', 'fft_shift', 'adc_ctrl0', 'acc_len']
  accum_reg_keys = ['status', 'sync_start', 'sys_scratchpad', 'acc_cnt',
                    'sync_cnt', 'sys_clkcounter']

  def __init__(self, parent          = None,
                     roach           = 'roach1',
                     template        = 'sao',
                     firmware_server = None,
                     firmware_key    = "sao_spec",
                     port            = None,
                     roach_log_level = logging.INFO,
                     clock_synth     = None,
                     acc_time        = 1,
                     writer_queue    = None,
                     write_to_disk   = False,
                     TAMS_logging    = False,
                     timing_report   = False):
    mylogger.debug("__init__: initializing %s", roach)
    # the first argument (after 'self') is the object providing 'action'
    DeviceReadThread.__init__(self, self, self.action, name=roach+"-reader",
                              suspend=True)
    mylogger.debug("__init__: initializing %s hardware", roach)
    self.name = roach
    self.parent = parent
    self.logger = mylogger
    self.RFchannel = {0: SAOfwif.Channel(self, "RF0")}
    # integration (number of accumulations)
    self.acc_count = 0
    self.max_count = 100 # dummy value over-written by start()
    # metadata needed for datafile
    self.header = self.get_register_values()
    # open datafile and initialize
    self.initialize_roach(acc_time=acc_time, timing_report=timing_report)
    self.daemon = True
    self.start()
    self.suspend_thread()
    self.scan = 1

  def initialize_roach(self, RF_gain=10, RFid=0, acc_time=1,
                       timing_report=False):
    """
    Initialises the system to defaults.

    For ROACH2 it will be necessary to loop over RF channels.
    """
    self.logger.debug("initialize_roach: entered for %s", self.name)
    # FFT shift comes from firmware spreadsheet
    self.fft_shift_set(self.fft_shift)
    self.logger.info("initialize_roach: fft shift = %s", bin(self.fft_shift))
    # default gain is 10 dB
    self.RFchannel[0].rf_gain_set(RF_gain)
    self.get_gains() # allows for multiple channels
    self.logger.info("initialize_roach: %4.1f dB gain enabled is %s",
                     self.gains[RFid]['gain'], self.gains[RFid]['enabled'])
    # default integration time per accumulation is 1 sec
    self.acc_time_set(acc_time)
    self.ctrl_set(flasher_en=False, cnt_rst='pulse', clr_status='pulse')
    self.logger.info("initialize_roach: %d accumulations acquired",
                     self.get_accum_count())
    self.get_gains()

  def action(self):
    """
    This provides the action for the child readers.

    The 'DeviceReadThread' objects created during initialization invoke their
    parents' (this object) 'action' method.

    It keeps track of the number of accumulations. It saves the data with
    associated header values for each accumulation.  When the number of
    accumulations equals the requested number, it stops and reports.
    """
    self.acc_count += 1
    if self.acc_count > self.max_count:
      self.suspend_thread()
      self.logger.debug("action: max accum count exceeded")
      # requested number of integrations (accumulations) is done
      UTtime = calendar.timegm(time.gmtime())
      self.parent.start.cb(("done", self.name, self.scan, UTtime))
      # start a new scan
      self.acc_count = 0  # reset counter
      # increment scan and create new scan group
      self.scan += 1
    else:
      # Get another integration (accumulation)
      accum = self.get_next_accum()
      self.parent.start.cb(("record", self.name, self.acc_count, accum))
      self.logger.debug("action: %s got integration %d", self.name,
                        self.acc_count)
      self.logger.debug("action: accum type is %s", type(accum))

  def calibrate(self):
    """
    Calibrate the FPGA.
    """
    pass
  
  def get_ambient_temp(self):
    """Get the ambient ADC temp"""
    return 40.

  def get_adc_temp(self):
    """Get the adc temp"""
    return 70.

  def get_clk(self):
    """Get an estimate of the FPGA clock speed."""
    return 640.
  
  def sync_start(self):
    """
    Initiate the sync pulses
    """
    # something here to start the accumulation counter
    
  def fft_shift_set(self, fft_shift_schedule=int(0b0000000000000000)):
    """
    Sets the FFT shift schedule (divide-by-two) on each FFT stage.

    Input is an integer representing a binary bitmask for shifting.
    If not specified as a parameter to this function (or a negative
    value is supplied), it programs the default level.
    """
    pass
  
  def get_gains(self):
    """
    Get the gains of the RF channels

    @return: dict of gains[ADC][RF]
    """
    self.gains = {}
    for RFid in self.RFchannel.keys():
      self.RFchannel[RFid].rf_gain_get()
      self.gains[RFid] = {'enabled': self.RFchannel[RFid].rf_enabled,
                          'gain': self.RFchannel[RFid].rf_gain}
    return self.gains

  def acc_time_get(self):
    """
    Get the accumulation length.
    """
    return self.acc_time

  def acc_time_set(self, acc_time=1):
    """
    Set the accumulation length in seconds
    """
    self.acc_time = acc_time
    self.accs_per_sec = int(round(float(self.bandwidth * 1e6) / self.num_chan))
    self.n_accs = int(round(acc_time * self.accs_per_sec))
    self.logger.info(
      "acc_time_set: %s accum. time set to %2.2f sec (%i accumulations).",
      self.name, acc_time, self.n_accs)
    self.sync_start()

  def ctrl_set(self, **kwargs):
    """
    Set control register bits.
    """
    pass

  def ctrl_get(self):
    """
    Reads and decodes the values from the control register.
    """
    pass

  def read_register(self, register):
    """
    To allow a client to read register
    """
    pass

  def ADC_samples(self, trig_level=-1, timeout=1):
    """
    Returns ADC samples.
    """
    # put in numpy array computation
    pass

  def get_ADC_input(self):
    """
    Get the ADC input level properties and a set of samples
    """
    samples = self.ADC_samples()
    if samples is None:
      self.logger.warning(
        "get_ADC_input: ADC_samples() needs to be defined in a subclass")
      return None
    else:
      level = {}
      level["sample mean"] = samples.mean()
      level["sample std"] = samples.std()
      self.logger.debug("get_ADC_input: %5.1f +/- %5.1f",
                        level["sample mean"],
                        level["sample std"])
      level["Vrms ADC"] = level["sample std"] * adc_cnt_mv_scale_factor() / 1000
      level["W ADC"] = volts_to_watts(level["Vrms ADC"])
      level["dBm ADC"] = v_to_dbm(level["Vrms ADC"])
      return level, samples

  def get_RF_input(self):
    """
    Get the mean RF section input level..

    This is the ADC level minus the gain of the RF section
    """
    level = self.get_ADC_input()[0]
    if level is not None:
      # Kurtosis spectrometer has only one ADC in ZDOC 0.
      dBgain = self.gains[0][0]['gain']
      level["dBm RF"] = level["dBm ADC"] - dBgain
      factor = gain(dBgain)
      level["W RF"] = level["W ADC"] / factor
    return level

  def get_accum_count(self):
    """
    """
    return self.fpga.read_int('acc_cnt')

  def get_spectrum(self):
    """
    """
    spec = self.read_fpga_uscram(0)[0]
    for sp in [1, 3, 2]:
      spec = numpy.append(spec, self.read_fpga_uscram(sp)[0])
    return spec

  def get_next_accum(self):
    """
    Suggested by Jonathan::
      acc_new = fpga.read(acc_cnt)
      if acc_new == acc_old
          do nothing
      else if  acc_new == acc_old + 1
        read_bram
        acc_old = acc_new
      else
        missed an accumulation, throw an error
      end
    """
    # get the current value
    accum_cnt = self.get_accum_count()
    done = False
    while not done:
      # check for a change
      new_cnt = self.get_accum_count()
      if new_cnt == accum_cnt:
        time.sleep(self.acc_time/10.)
      elif new_cnt == accum_cnt + 1:
        done = True
      else:
        # various possibilities here
        if new_cnt == 0:
          # bogus; ignore
          pass
        elif new_cnt > 1e9:
          # weird bit pattern
          self.logger.warning("get_next_accum: weird bit pattern")
        elif new_cnt > self.max_count + 10:
          # missed the last N spectra
          self.logger.error("get_next_accum: %s missed %d spectra",
                          self.name, new_cnt - (accum_cnt + 1))
        done = True
    return self.get_spectrum()

  def quit(self):
    """
    """
    if self.parent is not None:
      if hasattr(self.parent, "quit"):
        self.parent.quit.cb(("file", self.data_file_obj.file.filename,
                              calendar.timegm(time.gmtime())))
    self.logger.info("quit: %s closed.", self.data_file_obj.file.filename)
    self.data_file_obj.close()

  def help(self):
    return SAOfwif.command_help

  class Channel(support.PropertiedClass):
    """
    A logical spectrometer corresponding to one 'polarization' in firmware.

    Polarizations here means independent inputs.  They need not be orthogonal
    polarizations of the same signal.

    One channel corresponds to one RF input, one of several identical signal
    processing paths.  It produces one power and one kurtosis spectrum.

    Public Attributes::
      fpga          - parent.fpga, the FPGA which implements this spectrometr
      freqs         - freqs.freqs
      logger        - logging Logger instance for this class
      name          -
      parent        - Kurt_fwif() instance
      num_chan      - number of channels
      self.parent   - ROACH (SAOfwif object) to which this channel belongs
      pol           - basically the ADC RF input, 0 or 1.
      refpix        - channel number for center frequency
      rf_enabled    - RF status of each ADC
      rf_gain       - RF gain of each ADC channel
      RFnum         -
      roach         - name of the host ROACH
      stats         - signal statistic type (e.g. variance, kurtosis)
    Methods:::
      ADC_samples   -
      get_accums    -
      get_ADC_input -
      get_ADC_snap  -
      get_RF_input  -

    Attributes inherited from PropertiedClass::
      base -
      keys -

    Methods inherited from PropertiedClass::
      has_key -
    """
    def __init__(self, parent, name, active=True):
      """
      Initialize a logical spectrometer

      @param parent : object which created this instance
      @type  parent : KurtosisSpectrometer.DSProc instance
      """
      self.name = name
      self.RFnum = int(name[-1])
      self.parent = parent
      self.logger = logging.getLogger(parent.logger.name+".Channel")
      self.logger.debug(" __init__: for %s", self)
      self.logger.debug("__init__: providing logic for %s",
                          self.parent.roach)
      self.roach = self.parent.roach
      self.freqs = self.parent.freqs
      self.rf_gain = {}
      self.rf_enabled = {}
      self.rf_gain_get()

    def rf_gain_get(self):
      """
      Get the gain of the RF stage; sets attribute rf_gain
      """
      self.rf_enabled = response['enabled']
      self.rf_gain = response['gain']
      self.logger.info("rf_get_gain: %s gain[0] = %f, enabled = %s",
                        self.name, self.rf_gain, self.rf_enabled)

    def rf_gain_set(self, gain=0):
      """
      Configures the RF attenuators.

      For KATADC boards. KATADC's valid range is -11.5 to 20dB.
      """
      self.logger.debug("rf_gain_set: setting RF%d gain to %5.1f",
                        self.RFnum, gain)
      corr.katadc.rf_fe_set(self.fpga, 0, "I", gain=gain, enabled=True)
      self.rf_gain_get()

    def get_accums(self):
      """
      Get the power and kurtosis from their accumulation registers.
      """
      pass

    def get_ADC_snap(self, now=False):
      """
      Get the contents of the specified ADC snap block.

      @param now : True: a snap is triggered.  False: the last data are read.
      """
      self.logger.debug("get_ADC_snap: called for %s", self.roach)
      pass
      return numpy.array(data, dtype=numpy.int8)

    def get_ADC_input(self):
      """
      Signal level into the ADC in various units.
      """
      self.logger.debug("get_ADC_input: called for RF %d", self.RFnum)
      samples = self.get_ADC_snap(now=True)
      if samples is None:
        self.logger.warning("get_ADC_input failed to get samples")
        return None
      else:
        level = {}
        level["sample mean"] = samples.mean()
        level["sample std"]  = samples.std()
        level["Vrms ADC"] = level["sample std"]*adc_cnt_mv_scale_factor()/1000
        level["W ADC"] = volts_to_watts(level["Vrms ADC"])
        level["dBm ADC"] = v_to_dbm(level["Vrms ADC"])
        self.logger.info("get_ADC_input: %s", level)
        return level

    def ADC_samples(self):
      """
      """
      return self.get_ADC_snap(now=True)

    def get_RF_input(self):
      """
      Signal level into the KATADC RF section
      """
      level = self.get_ADC_input()
      if level != None:
        # Kurtosis spectrometer has only one ADC in ZDOC 0.
        level["dBm RF"] = level["dBm ADC"] - self.gain
        factor = gain(self.gain)
        level["W RF"] = level["W ADC"]/factor
      return level      


